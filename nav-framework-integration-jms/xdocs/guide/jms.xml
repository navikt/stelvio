<?xml version="1.0" encoding="iso-8859-1"?>
<document>
	<properties>
		<title>Guide JMS</title>
	</properties>
	<body>
		<section name="Guide JMS">
			<subsection name="Oversikt">
				<p>
					<i>JMSService</i>
					er en konfigurerbar tjeneste som tillater bruk av asynkrone og synkrone operasjoner vha. JMS. Tjenesten konfigureres via Config/Spring framework.
				</p>
			</subsection>
			<subsection name="Hvordan benytte en JMSService">
				<p>
					<i>JMSService</i>
					arver fra
					<i>EnterpriseIntegrationService</i> og har kun én metode av interesse:
					<i>doExecute(ServiceRequest)</i>
					. Denne metoden vil sende en JMS-melding på den konfigurerte køen og vente på svar dersom synkron operasjon er konfigurert. Innholdet i beskjeden er avhengig av innholdet i
					<i>ServiceRequest</i>
					<source>
...
LocalService service = (LocalService)configInstance.getBean("BrevServer");
ServiceResponse response = service.execute( serviceRequest );
...
</source>
				</p>
			</subsection>
			<subsection name="Hvordan konfigurere en JMSService">
				<p>Konfigurasjonen av JMSService skjer vha. Spring Framework. En instans av JMSService er bundet opp mot én kø og vil alltid sende meldinger på samme format og håndtere retur meldinger likt. Dersom man ønsker å endre dette må det konfigureres en ny JMSService.</p>
				<p>
					Følgende egenskaper ved JMSService kan konfigureres:
					<table>
						<tr>
							<td>isSynchronous</td><td>bestemmer om operasjon skal være synkron eller asynkron.(Ikke påkrevd, Default:false)</td>
						</tr>
						<tr>
							<td>queueJndi</td><td>JNDI navnet på køen beskjeder skal sendes på.(Påkrevd)</td>
						</tr>
						<tr>
							<td>queueConnectionFactoryJndi</td><td>JNDI på JMS QueueConnectionFactory som skal benyttes for oppkobling mot JMS.(Påkrevd)</td>
						</tr>
						<tr>
							<td>specifyReturnQueue</td><td>om retur køen skal spesifiseres på meldingen slik at systemet det integreres mot kan svare på ønsket kø.(Ikke påkrevd, Default:false)</td>
						</tr>
						<tr>
							<td>useTempQueue</td><td>om retur køen skal være en temporær kø. Denne krever at specifyReturnQueue=true(Ikke påkrevd, Default:false)</td>
						</tr>
						<tr>
							<td>returnQueueJndi</td><td>JNDI navnet på retur køen dersom synkron operasjon benyttes og man ikke benytter temporære køer.(Påkrevd dersom man benytter retur kø og bruk av temp kø er satt til false)</td>
						</tr>
						<tr>
							<td>
								timeout</td><td>hvor mange millisekunder et synkront kall skal vente før det gir opp. (Ikke påkrevd, Default:0) Kan settes til:
								<ul>
									<li>-1 - Svaret forventes å være tilgjengelig umiddelbart</li>
									<li>0 - JMSService vil vente helt til det kommer et svar, potensiellt uendelig.</li>
									<li>&gt;0 - JMSService vil vente det spesifiserte antall millisekunder på et svar.</li>
								</ul>
							</td>
						</tr>
						<tr>
							<td>messageHandler</td><td>En klasse som tilbyr spesialbehandling av retur beskjeden. (Påkrevd dersom isSynchronous=true)</td>
						</tr>
						<tr>
							<td>messageFormatter</td><td>En klasse tilbyr spesialbehandling av den utgående beskjeden.(Påkrevd)</td>
						</tr>
						<tr>
							<td>messageTtl</td><td>Time-to-live i millisekunder. Hvor lenge en beskjed skal være gylding før den går ut på dato.(Ikke påkrevd, Default:0)</td>
						</tr>
						<tr>
							<td>messageSelector</td><td>En tekst streng som bestemmer hvilke beskjeder som skal mottas ved synkron operasjon. Se
							<a href="http://hpapt03/j2ee131/api/javax/jms/Message.html">javax.jms.Message</a>
							for konfigurering av denne.(Ikke påkrevd)
							</td>
						</tr>
						<tr>
							<td>lookupHelper</td><td>En bean som benyttes for JNDI oppslag</td>
						</tr>
					</table>
				</p>
				<p>For hver JMSService må det konfigureres en MessageFormatter og en MessageHandler dersom den skal benyttes synkron operasjon. Eksempel på konfigurasjon av en JMSService:</p>
				<source>
					<![CDATA[
<beans>
	<bean id="BrevServer" class="no.nav.integration.framework.jms.JMSService" singleton="true" init-method="init">
		<property name="isSynchronous"><value>true</value></property>
		<property name="queueJndi"><value>jms/queue/BrevServerQueue</value></property>
		<property name="queueConnectionFactoryJndi"><value>jms/qcf/JMSQCF</value></property>
		<property name="specifyReturnQueue"><value>true</value></property>
		<property name="useTempQueue"><value>true</value></property>
		<property name="timeout"><value>30000</value></property> <!-- vent i 30 sekunder -->
		<property name="messageHandler"><ref bean="XMLMessageHandler"/></property>
		<property name="messageFormatter"><ref bean="XMLMessageFormatter"/></property>
		<property name="messageTtl"><value>30000</value></property>
		<property name="lookupHelper"><ref bean="ResourceLookupHelper"/></property>
	</bean>
	<bean id="XMLMessageFormatter" singleton="true" init-method="init">
		<!-- Se XMLMessageFormatter -->
	</bean>
	<bean id="XMLMessageHandler" singleton="true" init-method="init">
		<!-- Se XMLMessageHandler -->
	</bean>
	<bean id="ResourceLookupHelper" class="no.trygdeetaten.common.framework.util.ResourceLookupHelper" />
</beans>		
					
				]]>
				</source>
				<p>
					Legg spesielt merke til at
					<i>init-metod</i>
					er brukt på bønnen.
					<i>init-method</i>
					vil kalles av Spring Framework etter at alle properties er satt på bønnen. JMSService benytter denne metoden til å validere riktig konfigurasjon og slå oppe Queue og QueueConnectionFactory på JNDI treet. Hvis denne metoden ikke kalles, vil JMSService ikke fungere.
				</p>
				<p>
					Det anbefales at JMSService konfigureres til å være en singelton, men dette er ikke et krav. Spring Framework vil lage alle beans som singeltons hvis
					<i>singleton</i>
					ikke er spesifisert på bønnen.
				</p>
			</subsection>
			<subsection name="Message formatters">
				<p>
					Enhver instans av JMSService må konfigureres med en MessageFormatter implementasjon. En MessageFormatter har har ansvaret for følgende:
					<ul>
						<li>beskjed typen som sendes er korrekt (TextMessage, ObjectMessage, etc.).</li>
						<li>formatet på beskjeden er korrekt i forhold til hvilket system beskjeden skal sendes til.</li>
						<li>å vite hvilke felter som skal hentes fra ServiceRequest og sendes.</li>
						<li>hvilke header felter som må settes på beskjeden.</li>
					</ul>
					Alle message formatters har en init metode som bør konfigureres som
					<i>init-method</i>
					.
				</p>
				<h4>XMLMessageFormatter</h4>
				<p>
					For å kunne formatere beskjeder til å ha XML-innhold kan man benytte XMLMessageFormatter.
					<source>
						<![CDATA[
<bean id="XmlFormatter1" class="no.nav.integration.framework.jms.XMLMessageFormatter" singleton="true" init-method="init">
	<!-- Header felter -->
	<property name="jmsCorrelationId"><value>feltIRequest</value></property>
	<property name="keyField"><value>feltIRequest</value></property>
	<property name="xmlFileMappings">
		<map>
			<entry key="Online"><value>OnlineLetter.xml</value></entry>
			<entry key="Batch"><value>BatchLetter.xml</value></entry>
		</map>
	</property>
	<property name="fieldNames">
		<list>
			<value>feltIRequest1</value>
			<value>feltIRequest1</value>
		</list>
	</property>
	<property name="dynamicHeaderFields">
		<map>
			<entry key="headerField1"><value>value1</value></entry>
			<entry key="headerField2"><value>value2</value></entry>
		</map>
	</property>
	<property name="staticHeaderFields">
		<map>
			<entry key="headerField1"><value>value1</value></entry>
			<entry key="headerField1"><value>value2</value></entry>
			<entry key="headerField1"><value>value3</value></entry>
		</map>
	</property>
</bean>					
					]]>
					</source>
					XMLMessageFormatter produserer en
					<i>javax.jms.TextMessage</i>
					og benytter seg av
					<a href="http://hpapt03/j2sdk141/api/java/text/MessageFormat.html">java.text.MessageFormat</a>
					for å sette verdiene inn i XML'en.
				</p>
				<p>
					XMLMessageFormatter har følgende egenskaper:
					<table>
						<tr>
							<td>jmsCorrelationId</td><td>navnet for feltet i request'en som skal benyttes for å unikt identifisere denne klienten. Hvis denne ikke er spesifisert bli den bli generert (Valgfri).</td>
						</tr>
						<tr>
							<td>keyField</td><td>hvilket felt i request'en som forteller hvilken beskjed mal som skal benyttes (Obligatiorisk).</td>
						</tr>
						<tr>
							<td>xmlFileMappings</td><td>en map som kobler en nøkkel mot en beskjed mal. Verdien i "keyField" vil bestemme hvilken av disse malene som skal benyttes (Obligatorisk).</td>
						</tr>
						<tr>
							<td>
							fieldNames</td><td>hvilke felter fra request skal settes inn i malen. Rekkefølgen er viktig! (se
							<a href="http://hpapt03/j2sdk141/api/java/text/MessageFormat.html">java.text.MessageFormat</a>
							) (Valgfri).</td>
						</tr>
						<tr>
							<td>dynamicHeaderFields</td><td>en map som beskriver navnet på et header felt og hvilket felt fra request'en som skal settes inn i feltet (Valgfri).</td>
						</tr>
						<tr>
							<td>staticHeaderFields</td><td>en map som beskriver navnet på et header felt og hvilket forhåndsdefinert verdi som skal settes inn i feltet (Valgfri).</td>
						</tr>
					</table>
					Dersom en dynamicHeaderField og staticHeaderField har samme navn, vil et dynamicHeaderField overskrive en staticHeaderField. På denne måten kan en staticHeaderField verdi fungere som en "default verdi" dersom dynamicHeaderField med samme navn ikke er satt. Ingen header felter kan være null, men de kan være blanke strenger.
				</p>
				<p>Et felt som ikke finnes i input vil bli en blank streng i beskjeden.</p>
				<p>
					For å kunne aksessere verdier som ligger lagret på en hierarkisk måte støtter XMLFormatter at man spesifisere disse feltene adskillt med et punktum. Eks:
					<pre>felt1.felt2.felt3</pre>
					Dersom objektet er et TransferObject så må den inneholde et felt som heter "felt1" som igjen inneholder et objekt med feltet "felt2". Dersom objektet er av en annen type enn TransferObject så må dette følge standard JavaBeans konvesjon og ha en en getter metode for feltet: getFelt1().
				</p>
				<p>
					Eksempel:
					<br />
					Vi har en struktur med et TransferObject som inneholder et person objekt. XMLFormatter er konfigurert til å hente følgende felt: person.fornavn. Transfer objektet må ha et felt som heter <i>person</i>. Dette feltet må inneholde person objektet. Person objektet må ha en metode som heter <i>getFornavn()</i>.
				</p>
			</subsection>
			<subsection name="Message handlers">
				<p>
					Enhver instans av JMSService som benytter synkron operasjon må konfigureres med en MessageHandler implementasjon. En MessageHandler har ansvaret for følgende:
					<ul>
						<li>vite typen på retur beskjeden (TextMessage, ObjectMessage, etc.).</li>
						<li>vite formatet på retur beskjeden.</li>
						<li>å vite hvilke felter som skal settes på ServiceResponse og returneres.</li>
						<li>ta seg av feilhåndtering fra systemet.</li>
					</ul>
					Alle message handlere har en init metode som burde konfigureres som
					<i>init-method</i>
					.
				</p>
				<h4>XMLMessageHandler</h4>
				<p>
					XMLMessageHandler håndterer
					<i>javax.jms.TextMessage</i>
					som inneholder XML beskjeder. For å kunne hente verdier fra XML strukturen benytter denne en enkel versjon av XPath for å identifisere verdier. Denne versjonen av xpath støtter bare elements og attributes og ikke tester.
					<br/>
					<table>
						<tr>
							<th>Støttes</th>
							<th>Støttes ikke</th>
						</tr>
						<tr>
							<td>/element1/element2</td>
							<td>/element1/element2[0]</td>
						</tr>
						<tr>
							<td>/element1/element2/@attribute1</td>
							<td>/element1/element2[@attribute='X']</td>
						</tr>
					</table>
					<br/>
					Eksempel på konfigurasjon:
					<source>
						<![CDATA[
<bean id="XMLHandler1" class="no.nav.integration.framework.jms.handler.XMLMessageHandler" singleton="true" init-method="init">
	<!-- Header felter -->
	<property name="headerFields">
		<map>
			<entry key="headerFieldName1"><value>responseField1</value></entry>
			<entry key="headerFieldName2"><value>responseField1</value></entry>
		</map>
	</property>
	<property name="reponseFields">
		<map>
			<entry key="/data/gren1/blad1"><value>responseField1</value></entry>
			<entry key="/data/gren2/blad2/@attributt2"><value>responseField2.x.y</value></entry>
			<entry key="/data/gren3/blad3/@attributt3"><value>responseField3</value></entry>
		</map>
	</property>
	<property name="responseClassNames">
		<map>
			<entry key="responseField1"><value>class1</value></entry>
			<entry key="responseField2"><value>class2</value></entry>
			<entry key="responseField3"><value>class3</value></entry>
		</map>
	</property>
	<property name="staticResponseFields">
		<map>
			<entry key="navnPåResponseFelt"><value>verdi</value></entry>
		</map>
	</property>
	<property name="statusMessageField"><value>/data/status</value></property>
	<property name="statusResponseField"><value>status</value></property>
	<property name="errorMessageField"><value>/data/error</value></property>
	<property name="exceptionOnError"><value>true</value></property>
</bean>					
					]]>
					</source>
					XMLMessageHandler har følgende egenskaper:
					<table>
						<tr>
							<td>headerFields</td><td>En map med hvilke felter fra JMS headeren som skal inn i respons objektet (Valgfri)</td>
						</tr>
						<tr>
							<td>responseFields</td><td>En map med hvilke elementer og atributter fra XML'en som skal inn i retur objektet (Påkrevd).</td>
						</tr>
						<tr>
							<td>responseClassNames</td><td>hvilke typer som sakl setter på ServiceResponse.</td>
						</tr>
						<tr>
							<td>staticResponseFields</td><td>En map med statiske verdier som skal inn i retur objektet (Valgfri).</td>
						</tr>
						<tr>
							<td>statusMessageField</td><td>Hvilket felt i XML responsen som inneholder status melding/kode (Valgfri).</td>
						</tr>
						<tr>
							<td>statusResponseField</td><td>Hvilket felt i responsen som skal ha status koden (Valgfri).</td>
						</tr>
						<tr>
							<td>errorMessageField</td><td>Hvilket felt i XML responsen som inneholder en feilmelding (Valgfri).</td>
						</tr>
						<tr>
							<td>errorResponseField</td><td>hvilket responsen som skal ha feilmeldingen (Valgfri).</td>
						</tr>
						<tr>
							<td>errorStatus</td><td>En list over alle statuser som regner som feil (Valgfri).</td>
						</tr>
						<tr>
							<td>exceptionOnErrorStatus</td><td>on en ServiceFaileException skal kastes dersom status er feil (Valgfri).</td>
						</tr>
						<tr>
							<td>exceptionOnError</td><td>on en ServiceFaileException skal kastes dersom det finnes en feilmelding (Valgfri).</td>
						</tr>
					</table>
					Dersom et staticResponseField
					har samme navn som et responseField vil et responseField overskrive verdien av et staticResponseField. Hvis et staticResponseField har samme navn
					som et headerField vil et headerField overskrive verdien av et staticResponseField. Dersom et headerField og responseField har samme navn vil
					også her responseField overskrive headerField.
					
				</p>
				<p>
					På samme måte som XMLMessageFormatter så støtter XMLMessageHandler hierarkiske metode kall (felt1.felt2.felt3). Siden ServiceResponse ikke inneholder
					noen type informasjon må dette konfigureres. Dette må man kun konfigurere på øverste nivå, altså hvilke typer som skal settes på ServiceResponse.
					Underliggede typer klarer XMLMessageHandler å finne ut selv. Altså hvis man har et felt "x.y.z" som skal settes, så må
					XMLMessageHander vite hvilken type "x" er. Dette må være det fullt kvalifiserte klassenavnet (pakkenavn.Klassenavn). Objekter som skal ligge direkte
					på ServiceResponse må enten være en java.lang.String eller en JavaBean med get og set metoder.
					Hvis objektet er en String så kan feltnavnet IKKE være hierarkisk. En String som ligger direkte på ServiceResponse må være konfigurert med
					verdien "String".
				</p>
				<p>
					Noen spesielle regler gjelder for konfigurering av feilhåndtering:
					<ul>
						<li>Hvis statusMessageField er satt så kan ikke exceptionOnErrorStatus, statusResponseField eller errorStatus være satt</li>
						<li>Hvis exceptionOnErrorStatus er true så må det finnes en liste over hvilke status som regnes som feil</li>
						<li>exceptionOnErrorStatus kan ikke være true hvis statusResponseField er satt</li>
						<li>errorMessageField vil ikke bli benyttet med mindre statuen er en feilstatus</li>
						<li>exceptionOnError og exceptionOnErrorStatus kan ikke være true samtidig.</li>
						<li>exceptionOnError kan ikke være true hvis errorResponseField finnes.</li>
					</ul>
					Man trenger ikke benytte seg av status selv om man vil benytte error konfigureringen og omvendt.
					Hvis f.eks. det er feil dersom der finnes en feilmelding og ikke en feil dersom feltet er blank så kan
					man konfigurere dette uten status.
				</p>
				
			</subsection>
			<subsection name="Grensesnitt">
				<p>
					Følgende systemer benytter et JMS/MQ grensesnitt:
					<table>
						<tr>
							<th>System</th>
							<th>Formatter/Handler</th>
							<th>Grensesnittsbeskrivelse</th>
						</tr>
						<tr>
							<td>Brevserver</td>
							<td>XMLMessageFormatter/XMLMessageHandler</td>
							<td>
								<a href="\\s2900002\Prosjektarkiv\Moderniseringsarbeidet\Ma_arkiv\6_Sysdok\1_Dialogue\MA61009.008 Dialogue Systemintegrasjon.doc" target="Brevserver">MA61009.008 Dialogue Systemintegrasjon.doc</a>
							</td>
						</tr>
						<!--
						<tr>
							<td>TPS</td>
							<td>XMLMessageFormatter/XMLMessageHandler</td>
							<td>
								<a href="\\s2900002\Prosjektarkiv\Moderniseringsarbeidet\Gr_arkiv\8_Dokumentasjon\1_Tps\1_Delrapporter\GR8110057.200 XML-skjema for servicerutiner TPS.doc" target="TPS">GR8110057.200 XML-skjema for servicerutiner TPS.doc</a>
							</td>
						</tr>
						
						<tr>
							<td>Oppdrag</td>
							<td>FixedFieldFormatter/FixedFieldHandler</td>
							<td>Ikke bestemt</td>
						</tr>
						<tr>
							<td>Predator</td>
							<td>XMLMessageFormatter/XMLMessageHandler</td>
							<td>Ikke bestemt</td>
						</tr>
						-->
					</table>
				</p>
			</subsection>
			<subsection name = "Endringslogg">
<source><![CDATA[
$Log$
Revision 1.28  2004/08/31 08:40:10  tsb2920
Updated with LookupHelper

Revision 1.27  2004/06/17 10:39:51  tsb2920
Updated after review by Håvard Bjåstad

Revision 1.26  2004/06/16 14:38:39  tsb2920
Added CVS control of change log
]]>			
</source>
			</subsection>
		</section>
	</body>
</document>

