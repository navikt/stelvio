package no.stelvio.presentation.jsf.validator;

import java.text.SimpleDateFormat;
import java.util.Date;

import javax.faces.component.UIComponent;
import javax.faces.context.FacesContext;
import javax.faces.validator.ValidatorException;

import no.stelvio.presentation.binding.context.MessageContextUtil;

/**
 * DateRangeValidator validates whether the specified parameter is a date in a
 * range, and if invalid sets an error message on FacesContext.
 * 
 * @version $Id$
 */
public class DateRangeValidator extends AbstractFieldNameValidator {

	/** Minimum message key. */
	public static final String MINIMUM_MESSAGE_ID = "no.stelvio.presentation.validator.DateRange.MINIMUM";

	/** Maximum message key. */
	public static final String MAXIMUM_MESSAGE_ID = "no.stelvio.presentation.validator.DateRange.MAXIMUM";

	/** Not in range message key. */
	public static final String NOT_IN_RANGE_MESSAGE_ID = "no.stelvio.presentation.validator.DateRange.NOT_IN_RANGE";

	/** Date message key. */
	public static final String TYPE_MESSAGE_ID = "no.stelvio.presentation.validator.Date.TYPE";

	private static final String DATE_FORMAT = "dd.MM.yyyy";

	private Date minimum = null;

	private Date maximum = null;

	/**
	 * Validates whether the specified parameter is a date in between a maximum
	 * and minimum date value.
	 * 
	 * {@inheritDoc}
	 */
	public void validateField(FacesContext context, UIComponent component, Object value) throws ValidatorException {
		if (value != null) {
			Date valueDate = parseDateValue(component, value);

			if (minimum != null && maximum != null) {
				if (valueDate.getTime() < minimum.getTime() || valueDate.getTime() > maximum.getTime()) {
					SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT);
					Object[] args = { getFieldName(), dateFormat.format(minimum), dateFormat.format(maximum) };
					throw new ValidatorException(MessageContextUtil.getFacesMessage(NOT_IN_RANGE_MESSAGE_ID,
							args));
				}
			} else if (minimum != null) {
				if (valueDate.getTime() < minimum.getTime()) {
					Object[] args = { getFieldName(), new SimpleDateFormat(DATE_FORMAT).format(minimum) };
					throw new ValidatorException(MessageContextUtil.getFacesMessage(MINIMUM_MESSAGE_ID, args));
				}
			} else if (maximum != null) {
				if (valueDate.getTime() > maximum.getTime()) {
					Object[] args = { getFieldName(), new SimpleDateFormat(DATE_FORMAT).format(maximum) };
					throw new ValidatorException(MessageContextUtil.getFacesMessage(MAXIMUM_MESSAGE_ID, args));
				}
			}
		}
	}

	/**
	 * Parses the object value to a Date object.
	 * 
	 * @param uiComponent
	 *            the UIComponent
	 * @param value
	 *            the value to parse
	 * @return the parsed Date
	 */
	private Date parseDateValue(UIComponent uiComponent, Object value) {
		if (value instanceof Date) {
			return (Date) value;
		}
		Object[] args = { uiComponent.getId() };
		throw new ValidatorException(MessageContextUtil.getFacesMessage(TYPE_MESSAGE_ID, args));
	}

	/**
	 * Get maximum.
	 * 
	 * @return the maximum
	 */
	public Date getMaximum() {
		return maximum;
	}

	/**'
	 * Set maximum.
	 * 
	 * @param maximum
	 *            the maximum to set
	 */
	public void setMaximum(Date maximum) {
		this.maximum = maximum;
	}

	/**
	 * Get minimum.
	 * 
	 * @return the minimum
	 */
	public Date getMinimum() {
		return minimum;
	}

	/**
	 * Set minimum.
	 * 
	 * @param minimum
	 *            the minimum to set
	 */
	public void setMinimum(Date minimum) {
		this.minimum = minimum;
	}

	// RESTORE & SAVE STATE
	/**
	 * {@inheritDoc}
	 */
	public Object saveState(FacesContext context) {
		Object[] values = new Object[3];

		values[0] = super.saveState(context);
		values[1] = maximum;
		values[2] = minimum;
		return values;
	}

	/**
	 * {@inheritDoc}
	 */
	public void restoreState(FacesContext context, Object state) {
		Object[] values = (Object[]) state;

		super.restoreState(context, values[0]);
		maximum = (Date) values[1];
		minimum = (Date) values[2];
	}

	/**
	 * {@inheritDoc}
	 * 
	 * This is autogenerated by Eclipse.
	 * 
	 * @see java.lang.Object#hashCode()
	 */
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((maximum == null) ? 0 : maximum.hashCode());
		result = prime * result + ((minimum == null) ? 0 : minimum.hashCode());
		return result;
	}

	// MISC
	/**
	 * {@inheritDoc}
	 */
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (!(o instanceof DateRangeValidator)) {
			return false;
		}

		final DateRangeValidator dateRangeValidator = (DateRangeValidator) o;

		if (maximum != null ? !maximum.equals(dateRangeValidator.maximum) : dateRangeValidator.maximum != null) {
			return false;
		}
		if (minimum != null ? !minimum.equals(dateRangeValidator.minimum) : dateRangeValidator.minimum != null) {
			return false;
		}

		return true;
	}
}
