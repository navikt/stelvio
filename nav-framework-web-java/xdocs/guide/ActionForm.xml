<?xml version="1.0" encoding="iso-8859-1"?>
<document>
	<properties>
		<title>Action Form - Guide</title>
	</properties>
	<body>
		<section name="Action Form - Guide">
			
			<subsection name="Oversikt">
			
				<p>
					Service to Worker er i Struts implementert av Action klassen. Application controller
					finner riktig Action ved å slå opp i Action Mappingen definert i Struts konfigurasjonsfil.
					Det finnes et sett med Action klasser i Struts som kan brukes ved forskjellige behov.
					Action klassen utvides til de enkelte action som skal utføres.
					<br/>
					ViewHelper er en JavaBean som formidler informasjon mellom web klienten og presentasjonslaget.
					I Struts er det enten en egen klasse for hver form eller, fra Struts 1.1, en dynamisk klasse som
					defineres i Struts konfigurasjonsfil.
				</p>
			
				
			</subsection>
			
			<subsection name="Action">
			
				<h4>Opprette en Action klasse</h4>
					<p>
						En Actionklasse inneholder alle metoder knyttet til et enkelt vindu i applikasjonen for å holde
						logikken til moduler koblet sammen. Alle hendelser i et vindu har altså en metode i actionklassen
						som utfører hendelsen.
						<br/>
						En Action skal arve fra FindDispatchAction for at riktig metode skal bli kjørt i Actionklassen.
						Alle metoder i Actionklassen må begynne med 'execute' og så metodenavn f.eks. <i>executeMethod1</i>.
						Arkitekturen finner metoden som skal kjøres i requesten som sendes fra klienten.
						I formen som sendes fra klienten må det også være en parameter som begynner på execute og som 
						matcher den metoden som ønskes å kjøre.
						<br/>
						I FindDispatchAction ligger også en metode som returnerer BussinesDelegate slik at kall til
						forretningslaget kan gjøres.
					</p>

				<h4>Eksempel på en Action</h4>

					<p>	Execute metoder som implementeres i Actionklassen må følge en standard signatur for å kunne finnes
						av arkitekturen. Signatur og eksempel:
					</p>
<source>
public ActionForward executeMethodName(ActionMapping mapping,
    ActionForm form,
    HttpServletRequest request,
    HttpServletResponse response)
  throws Exception
  
public ActionForward executeMinus(ActionMapping mapping,
	ActionForm form,
	HttpServletRequest request,
	HttpServletResponse response)
	throws IOException, ServletException {
		
	return RequestUtils.findForward(mapping, request, "Action2", form, "Action1, null");
}
</source>
					
					<p>
						Metoden RequestUtils.findForward() kan ha forskjellige antall parametere avhengig av hva som skal
						skje i navigeringen. Skal det være mulig å navigere tilbake til samme form med samme verdier registrert
						må retur stien og formen sendes med. 
						Så finnes det findForward for vanlig navigering til en annen action og en med retur til forrige vindu.
						Se javadoc.
						<br/>
						I JSPsiden vises knappene på vanlig måte. 
					</p>
<source><![CDATA[
<html:form action="/action1">
<html:submit>
<bean:message property="executeMinus" key="button.minus"/>
</html:submit>
<html:submit>
<bean:message property="executePluss" key="button.pluss"/>
</html:submit>
</html:form>
]]></source>

					<br/>

				<h4>Returverdier til en Action</h4>
					<p>
						En action skal kunne ta returverdier sendt fra andre actions, f.eks. etter et søk i et annet vindu.
						Dette må gjøres for at få det til:
						<li>Den action som skal kunne ta mot returverdien må si fra hvilket felt som skal ta mot verdien</li>
						<li>Den action som returnerer henter verdien fra returinformasjonen og legger verdien i et attribute</li>
						<li>Første action overstyrer så metoden executeLoad som legger verdien inn i formen</li>
						
						<br/>
						Den første action sender med formfeltet der verdien skal returneres til som siste parameter i 
						<code>findForward</code>. (<i>lastname</i> er feltet som skal settes av returverdien her)
					</p>
<source>
return RequestUtils.findForward(mapping, request, "Action3", form, "Action2", "lastname");
</source>

					Den andre action henter en verdi fra formen og returfeltet samt setter verdien i et request attribute.
<source>
DynaActionForm dynaForm = (DynaActionForm) form;

String name = (String)dynaForm.get("name");
String field = ReturnUtils.getReturnField(request);
request.setAttribute(field, name);

return RequestUtils.findForward(mapping, request);
</source>

					Den første action sin executeLoad henter attributet og setter det i formen som så vises frem.
<source>
DynaActionForm dynForm = (DynaActionForm) form;
String name = (String)request.getAttribute("name");

if (name != null) {
    dynForm.set("lastname", name);
}		
</source>

					
				<h4>Konfigurasjon</h4>
					<p>
						Definering av en action i struts-config.xml under <i>actions</i> taggen med en
						parameter som er navnet på knappene i en form.
					</p>
					<p>
						Dersom input i en ActionForm ikke skal valideres (f.eks. når et nytt vindu skal
						åpnes for å hente informasjon tilbake i formen), legges navnet på action-metoden
						(f.eks. <i>executeStart</i>) inn i en komma-separert liste under attributten 
						<i>parameter</i> (se under). Denne listen må ikke inneholde mellomrom.
						<i>executeLoad</i> valideres aldri.
					</p>
<source><![CDATA[
		<action path="/action1"
			type="no.nav.web.bidragproto.action.Action1"
			name="firstForm"
			scope="request"
			input="/pages/Welcome.jsp"
			parameter="executeGo,executeStart,executeFinish">
			<forward name="failure" path="/pages/Welcome.jsp" contextRelative="true"/>
			<forward name="windowload" path="/pages/Welcome.jsp" contextRelative="true"/>
			<forward name="success" path="/pages/Welcome.jsp" contextRelative="true"/>
			<forward name="action2load" path="/action2.do?executeLoad=Load" contextRelative="true" redirect="true"/>
		</action>		
]]></source>

			</subsection>
			
			<subsection name="Form">

				<h4>Opprette og konfigurere en Form Bean</h4>
					<p>
						En form er en JavaBean som enten finnes implementert som en klasse eller er dynamisk og
						definert i en konfigurasjonsfil. Det rekomenderes at en klasse lages for hver form
						isteden for å bruke dynamisk form. Dette fordi:
						<li>Dynamiske former ligger i struts-config	filen og den blir uoversiktlig med mange
						dynamiske former når alle feltene er beskrevet</li>
						<li>Hvis en klasseform endres trenger ikke serveren startes på nytt som en dynamisk form må</li>
						<li>Feil i en dynamisk form er vanskeligere å finne feil i siden reflection brukes</li>
						<li>Det går like snabbt å lage en klasse når gettere og settere genereres</li>						
						<br/>
						En form bean defineres i Struts konfigurasjonsfil når en dynamisk form brukes.
						Alle verdier i en form skal være av typen String for at	valideringen av
						feltene skal virke som ønsket.
						(Hvis det er andre typer og valideringen feiler kan det være problem med å få skrevet verdiene
						ut på siden)
						<br/>
						Se konfigurasjon av action i struts konfigurasjonsfil for hvordan en spesifikk form
						brukes i en action.
						<br/>
						For validering av en form se <a href="Validering.html">Validering guide</a>
						<br/>
						OBS! Hvis to former har felter med samme navn og de kommer etter hverandre så legges den 
						første formens verdi inn i den andre. Dette pga. at navigeringen går fra en action til neste
						action sin executeLoad uten å sende svar til klienten og da ligger samme verdi i requesten.
						Formnavnet har ikke noe å si det går kun på feltet.						
					</p>

				<h4>Eksempel fra konfigurasjonsfil</h4>
					<p>
						Definering av en dynamisk form i <i>form-beans</i> taggen.
					</p>
<source><![CDATA[
<form-bean
    name="LoginForm"
    type="org.apache.struts.action.DynaValidatorForm">
    <form-property name="username"
	type="java.lang.String"/>
    <form-property name="password"
	type="java.lang.String"/>
</form-bean>]]>
</source>
					<p>
						Definering av en action form. (En ikke dynamisk form som må kodes i java)
					</p>
<source><![CDATA[
<form-bean 
    name="LoginForm" 
    type="no.nav.web.prototype.form.LoginForm">
</form-bean>]]>
</source>

				<h4>Eksempel på kode i en action for å hente formsverdier</h4>
					<p>
						Hvordan formverdier hentes ut i en action.
					</p>
<source>
DynaActionForm loginForm = (DynaActionForm) form;
username = (String)loginForm.get("username");
</source>					

				<h4>Kopiere verdier fra transfer-objektet til formdata-objektet</h4>
					<p>
						Ofte ønsker man å kopiere verdier fra et transfer-objekt fra forretningslogikken inn i
						et formdata-objekt i presentasjonslaget. Istedenfor å kopiere hvert enkelt felt, kan
						<i>BeanUtils</i> benyttes dersom variablene har samme navn. Dette gjøres via et kall til
						<i>copyProperties</i> og verdier kopieres fra kilde-bønnen til mål-bønnen.
						Det er også mulig å konvertere fra en type til en annen (se under). <i>BeanUtils</i> 
						ignorerer variabler i de to bønnene som ikke har samme navn.
					</p>
<source>
	import org.apache.commons.beanutils.BeanUtils;
	
	...
	
	BeanUtils.copyProperties(målBønne, kildeBønne);
</source>
				
				<h4>Konvertering av data fra en type til en annen</h4>
					<p>
						Når <i>BeanUtils</i> benyttes for å kopiere verdier fra en bønne til en annen (se over),
						kan det være nødvendig å konvertere data fra én type til en annen. Et eksempel på dette
						er når data skal kopieres fra <i>HttpRequest</i>'en (hvor alle variabler er strenger) til
						formdata-objektet (hvor man gjerne har f.eks. dato-objekter). Man kan gjøre konverteringen
						ved å lage egne konverteringsklasser - én for hver måltype (f.eks. dato). Når konvertereren
						er registrert, gjøres konverteringen automatisk hver gang <i>copyProperties</i> kalles.
						Dersom man har en bønne med en liste med objekter av en gitt type som man ønsker å kopiere til
						en bønne med en liste av objekter av en annen type, må denne konverteringen gjøres manuelt, dvs.
						<i>copyProperties</i> kan brukes for listen men ikke for formen (ingen nestet konvertering på
						denne måten).
					</p>
					<p>
						Eksempel på konverteringsklasse:
					</p>
<source>
public class DateConverter implements Converter {

...
					
	public Object convert(Class type, Object value) throws ConversionException {

		if (value instanceof Date) {
			return (value);
		} else if (value instanceof String) {
			try {
				DateFormat parser = new SimpleDateFormat("dd/MM/yy");

				return (parser.parse((String) value));
			} catch (Exception e) {
				if (useDefault) {
					return (defaultValue);
				} else {
					throw new ConversionException(e);
				}
			}
		} else {
			throw new ConversionException(
				"Can NOT convert object of type "
					+ value.getClass().getName()
					+ " to java.util.Date!");
		}
	}	
}
</source>
					<p>
						Registrering av konverterer (dette bør gjøres i startup-servlet'en - merk
						at det kun kan registreres én konverter pr. mål-klasse):
					</p>
<source>
	import org.apache.commons.beanutils.ConvertUtils;

	...

	ConvertUtils.register(new DateConverter(), Date.class);
</source>

				<h4>Checkbox</h4>
					<p>
						En checkbox i en HTML side sendes kun til serveren hvis den er markert. Checkboxen må resettes
						for at man skal kunne se om brukeren har valgt den. Det gjøre ved at overstyre reset metoden i formen.
					</p>
<source><![CDATA[
public void reset(ActionMapping mapping, HttpServletRequest request) {
	typeKrav = false;
}
]]></source>

					
			</subsection>
			
			<subsection name = "Endringslogg">
<source><![CDATA[
$Log$
Revision 1.15  2004/09/07 08:53:04  cra2920
*** empty log message ***

Revision 1.14  2004/09/06 11:13:11  cra2920
Oppdatert info om konvertering

Revision 1.13  2004/09/06 11:05:00  cra2920
Lagt til info om BeanUtils og ConvertUtils

Revision 1.12  2004/08/24 11:33:00  cra2920
Oppdatert info om validering

Revision 1.11  2004/08/03 14:31:01  jla2920
Bedre beskrivelse av Form

Revision 1.10  2004/06/18 13:10:20  jla2920
Oppdatert etter review og satt inn ny endringslogg
]]>			
</source>
			</subsection>

		</section>
	</body>
</document>

